#!/usr/bin/env python
import os
import os.path
import sys
import re
from time import sleep
import signal
import subprocess
import logging, logging.config
from vFense._constants import (
    VFENSE_LOGGING_CONFIG, VFENSE_TMP_PATH, VFENSE_BASE_PATH,
    VFENSE_LOG_PATH, VFENSE_BASE_SRC_PATH
)
from vFense.utils.common import get_rqworkers

logging.config.fileConfig(VFENSE_LOGGING_CONFIG)
logger = logging.getLogger('vfense_api')

PID_DIR = VFENSE_TMP_PATH
PIDS = []
SERVICES = []
ALLSERVICES = []
LISTENERSERVICES = []
APISERVICES = []

#################################################################
RQWORKER = '/usr/local/bin/rqworker'
RQ_WORKER_QUEUES = get_rqworkers()
RQ_PID_FILES = []

for queue in RQ_WORKER_QUEUES:
    queue_name = re.sub(r'_settings.py', '', queue[1])
    pid_file = os.path.join(PID_DIR, 'rqw_pid_%s.pid' % (queue_name))
    PIDS.append((pid_file, queue))
    RQ_PID_FILES.append(pid_file)

#################################################################
LISTENER_PORTS = range(9020, 9030)
LISTENER = 'vFense_listener.py'
for port in LISTENER_PORTS:
    pid_file = os.path.join(PID_DIR, 'listener_pid_%s.pid' % (str(port)))
    msg = 'Listener port %s' % (str(port))
    PIDS.append((pid_file, msg))
    LISTENERSERVICES.append((LISTENER, pid_file, msg, port))
    ALLSERVICES.append((LISTENER, pid_file, msg, port))

##################################################################
API_PORTS = range(9060, 9061)
API = 'vFense_web.py'
for port in API_PORTS:
    pid_file = os.path.join(PID_DIR, 'api_pid_%s.pid' % (str(port)))
    msg = 'api port %s' % (str(port))
    PIDS.append((pid_file, msg))
    APISERVICES.append((API, pid_file, msg, port))
    ALLSERVICES.append((API, pid_file, msg, port))

##################################################################
VFENSE_HOME = VFENSE_BASE_PATH
PROGRAM = 'python'
PIDFILE = os.path.join(VFENSE_TMP_PATH, 'process.pid')
ADMIN_JOBS_PIDFILE= os.path.join(VFENSE_TMP_PATH, 'admin_jobs-9002.pid')
PATH = VFENSE_BASE_SRC_PATH
ADMIN_JOBS='jobs/admin_jobs.py'

PIDS.append((ADMIN_JOBS_PIDFILE, 'AdminJobs'))

if not os.path.exists(VFENSE_TMP_PATH):
    os.mkdir(VFENSE_TMP_PATH)
if not os.path.exists(VFENSE_LOG_PATH):
    os.mkdir(VFENSE_LOG_PATH)

SERVICES.append((ADMIN_JOBS, ADMIN_JOBS_PIDFILE, 'AdminJobs'))
ALLSERVICES.append((ADMIN_JOBS, ADMIN_JOBS_PIDFILE, 'AdminJobs'))

def run(program, *args):
    try:
        pid = os.fork()
        if not pid:
            os.execvp(program, (program,) + tuple(args))
    except OSError, e:
        sys.stderr.write("fork failed %d (%s)\n" %
                        (e.errno, e.strerror))
        logger.warning("fork failed %d (%s)\n" %
                      (e.errno, e.strerror))
        sys.exit(1)
    return str(pid)


def rqworker_starter():
    completed = True
    for queue in RQ_WORKER_QUEUES:
        queue_name = re.sub(r'_settings', '', queue[1])
        queue_dir = queue[0]
        queue_settings = queue[1].rstrip('.py')
        os.chdir(queue_dir)
        pid_file = os.path.join(PID_DIR, 'rqw_pid_%s.pid' % (queue_name))
        rqw = 'RqWorker Queue %s' % (queue_name)
        rqworker_start = (
            subprocess.Popen(
                [
                    RQWORKER, '-c', queue_settings
                ]
            )
        )
        rqworker_start.poll()
        rq_pid = str(rqworker_start.pid)
        os.chdir(PATH)
        if rq_pid:
            pid = open(pid_file, 'w')
            pid.write(rq_pid)
            pid.close()
            completed = True
            rql_msg = '%s started successfully\n' % (rqw)
            sys.stderr.write(rql_msg+'\n')
            logger.info(rql_msg)
        else:
            rql_msg = '%s stopped successfully\n' % (rqw)
            sys.stderr.write(rql_msg+'\n')
            logger.error(rql_msg)
            completed = False

    return(completed)

def rqworker_stop():
    completed = True

    for queue in RQ_WORKER_QUEUES:
        queue_name = re.sub(r'_settings', '', queue[1])
        pid_file = os.path.join(PID_DIR, 'RQW_PID_%s.pid' % (queue_name))
        rqw = 'RqWorker Queue %s' % (queue_name)
        if os.path.exists(pid_file):
            pid_exists = open(pid_file, 'r').read()
            if re.search(r'[0-9]+', pid_exists):
                try:
                    os.kill(int(pid_exists), signal.SIGTERM)
                    os.remove(pid_file)
                except Exception as e:
                    if e.errno == 3:
                        os.remove(pid_file)
                rql_msg = '%s stopped successfully\n' % (rqw)
                sys.stderr.write(rql_msg+'\n')
                logger.info(rql_msg)

            else:
                rql_msg = '%s couldnt be stopped\n' % (rqw)
                completed = False
                sys.stderr.write(rql_msg+'\n')
                logger.error(rql_msg)

        else:
            rql_msg = '%s couldnt be stopped\n' % (rqw)
            completed = False
            sys.stderr.write(rql_msg+'\n')
            logger.error(rql_msg)

    return(completed, rql_msg)


def handler(signum, frame):
    print "returning back to terminal"


def vfense_start():
    process_exists = 0
    for pidfile in PIDS:
        if os.path.exists(pidfile[0]):
            pid = open(pidfile[0], 'r').read()
            ps = subprocess.Popen(['ps', '-fe'], stdout=subprocess.PIPE)
            for i in ps.stdout.readlines():
                if re.search(r'[0-9]+', i.split()[1]):
                    if int(pid) == int(i.split()[1]):
                        process_exists = process_exists + 1
                        message = 'vFense service %s is already running.' \
                            % (pidfile[1])
                        sys.stderr.write(message+'\n')
                        logger.error(message)
                        sys.exit(1)
    if process_exists == 0:
        os.chdir(PATH)
        print 'vFense Server is starting. Please wait....'
        logger.info('vFense Server is starting. Please wait....')
        rqworker = rqworker_starter()
        if rqworker:
            for service in LISTENERSERVICES:
                pid = run(PROGRAM, service[0], '--port=%s' % (service[3]))
                pidfile = open(service[1], 'w')
                pidfile.write(pid)
                pidfile.close()
                logger.info("%s Server Started" % (service[2]))
            for service in APISERVICES:
                pid = run(PROGRAM, service[0], '--port=%s' % (service[3]))
                pidfile = open(service[1], 'w')
                pidfile.write(pid)
                pidfile.close()
                logger.info("%s Server Started" % (service[2]))
            for service in SERVICES:
                pid = run(PROGRAM, service[0])
                pidfile = open(service[1], 'w')
                pidfile.write(pid)
                pidfile.close()
                logger.info("%s Server Started" % (service[2]))
        sleep(1)
        signal.signal(signal.SIGINT, handler)
        print 'vFense Server has been started. Enjoy !!!'
        logger.info('vFense Server has been started. Enjoy !!!')


def vfense_stop():
    logger.info('vFense Services are going to shutdown now...')
    for service in ALLSERVICES:
        if os.path.exists(service[1]):
            pid = open(service[1], 'r').read()
            if re.search(r'[0-9]+', pid):
                try:
                    os.kill(int(pid), signal.SIGTERM)
                    os.remove(service[1])
                except Exception as e:
                    if e.errno == 3:
                        os.remove(service[1])
            sleep(2)
        else:
            msg = "vFense %s is not running. Stopping Failed..." \
                  % (service[2])
            sys.stderr.write(msg+'\n')
            logger.error(msg)

    rqworker_stop()

    print 'vFense Server has been stopped now !!!'
    logger.info('vFense Server has been stopped now !!!')


def vfense_restart():
    vfense_stop()
    print "\n"
    vfense_start()

def vfense_status():
    process_exists = 0
    for pidfile in PIDS:
        if os.path.exists(pidfile[0]):
            pid = open(pidfile[0], 'r').read()
            ps = subprocess.Popen(['ps', '-fe'], stdout=subprocess.PIPE)
            for i in ps.stdout.readlines():
                if re.search(r'[0-9]+', i.split()[1]):
                    if int(pid) == int(i.split()[1]):
                        process_exists = process_exists + 1
                        message = 'vFense service %s is running.' \
                            % (pidfile[1])
                        sys.stderr.write(message+'\n')
                        logger.info(message)
        else:
            message = 'vFense service %s is not running.' % (pidfile[1])
            sys.stderr.write(message+'\n')
            logger.error(message)
    sys.exit(0)

ACTIONS = sys.argv[1]

if __name__ == "__main__":
    if len(sys.argv) == 2:
        if ACTIONS == 'start':
            vfense_start()
        elif ACTIONS == 'stop':
            vfense_stop()
        elif ACTIONS == 'restart':
            vfense_restart()
            logger.info("vFense server restarting..")
        elif ACTIONS == 'status':
            vfense_status()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart|status" % sys.argv[0]
