#!/usr/bin/env python
import argparse
import ConfigParser
import os
import os.path
import re
import sys
from time import sleep
import signal
import subprocess
import logging, logging.config
from vFense._constants import (
    VFENSE_LOGGING_CONFIG, VFENSE_TMP_PATH, VFENSE_BASE_PATH,
    VFENSE_LOG_PATH, VFENSE_BASE_SRC_PATH, VFENSE_CONFIG
)
from vFense.utils.common import get_rqworkers

logging.config.fileConfig(VFENSE_LOGGING_CONFIG)
logger = logging.getLogger('vfense_api')

Config = ConfigParser.ConfigParser()
Config.read(VFENSE_CONFIG)

PID_DIR = VFENSE_TMP_PATH
PIDS = []
SERVICES = []
ALLSERVICES = []
LISTENERSERVICES = []
APISERVICES = []

parser = argparse.ArgumentParser(description='vFensed daemon')
parser.add_argument(
    '--rq-workers', dest='rq_workers', action='store_true',
    help='Start the redis queue workers with the daemon'
)
parser.add_argument(
    '--no-rq-workers', dest='rq_workers', action='store_false',
    help='Do not start the redis queue workers with the daemon'
)
parser.add_argument(
    '--admin-scheduler', dest='admin_scheduler', action='store_true',
    help='Start the admin scheduler for vFense'
)
parser.add_argument(
    '--no-admin-scheduler', dest='admin_scheduler', action='store_false',
    help='Do not start the admin scheduler for vFense'
)
parser.set_defaults(rq_workers=True)
parser.set_defaults(admin_scheduler=True)

args = parser.parse_args()


#################################################################
RQWORKER = '/usr/local/bin/rqworker'
RQ_WORKER_QUEUES = get_rqworkers()
RQ_PID_FILES = []

for queue in RQ_WORKER_QUEUES:
    queue_name = re.sub(r'_settings.py', '', queue[1])
    pid_file = os.path.join(PID_DIR, 'rqw_pid_%s.pid' % (queue_name))
    PIDS.append((pid_file, queue))
    RQ_PID_FILES.append(pid_file)

#################################################################
LISTENER_PORTS = range(9020, 9030)
LISTENER = 'vFense_listener.py'
for port in LISTENER_PORTS:
    pid_file = os.path.join(PID_DIR, 'listener_pid_%s.pid' % (str(port)))
    msg = 'Listener port %s' % (str(port))
    PIDS.append((pid_file, msg))
    LISTENERSERVICES.append((LISTENER, pid_file, msg, port))
    ALLSERVICES.append((LISTENER, pid_file, msg, port))

##################################################################
API_PORTS = range(9060, 9061)
API = 'vFense_web.py'
for port in API_PORTS:
    pid_file = os.path.join(PID_DIR, 'api_pid_%s.pid' % (str(port)))
    msg = 'api port %s' % (str(port))
    PIDS.append((pid_file, msg))
    APISERVICES.append((API, pid_file, msg, port))
    ALLSERVICES.append((API, pid_file, msg, port))


def get_port_settings(section="Listener"):
    start_port = Config.getint(section, "starting_port")
    end_port = Config.getint(section, "ending_port")

    return(start_port, end_port)

def get_pids_for_service(file_name, start_port, end_port):
    pids = []
    ports = range(start_port, end_port)
    name =  file_name.rstrip(".py")
    for port in ports:
        pid_file = (
            os.path.join(
                VFENSE_TMP_PATH,
                '{0}_pid_{1}.pid'.format(name, str(port))
            )
        )
        msg = '{0} port {1}' % (name, str(port))
        pids.append(
            {
                "service": file_name,
                "pid_file": pid_file,
                "msg": msg,
                "port": port
            }
        )
    return pids

##################################################################
VFENSE_HOME = VFENSE_BASE_PATH
PROGRAM = 'python'
PIDFILE = os.path.join(VFENSE_TMP_PATH, 'process.pid')
ADMIN_JOBS_PIDFILE= os.path.join(VFENSE_TMP_PATH, 'admin_jobs-9002.pid')
PATH = VFENSE_BASE_SRC_PATH
ADMIN_JOBS='jobs/admin_jobs.py'

PIDS.append((ADMIN_JOBS_PIDFILE, 'AdminJobs'))

if not os.path.exists(VFENSE_TMP_PATH):
    os.mkdir(VFENSE_TMP_PATH)
if not os.path.exists(VFENSE_LOG_PATH):
    os.mkdir(VFENSE_LOG_PATH)

SERVICES.append((ADMIN_JOBS, ADMIN_JOBS_PIDFILE, 'AdminJobs'))
ALLSERVICES.append((ADMIN_JOBS, ADMIN_JOBS_PIDFILE, 'AdminJobs'))

def run(program, *args):
    try:
        pid = os.fork()
        if not pid:
            os.execvp(program, (program,) + tuple(args))
    except OSError, e:
        sys.stderr.write("fork failed %d (%s)\n" %
                        (e.errno, e.strerror))
        logger.warning("fork failed %d (%s)\n" %
                      (e.errno, e.strerror))
        sys.exit(1)
    return str(pid)


def rqworker_starter():
    completed = True
    for queue in RQ_WORKER_QUEUES:
        queue_name = re.sub(r'_settings', '', queue[1])
        queue_dir = queue[0]
        queue_settings = queue[1].rstrip('.py')
        os.chdir(queue_dir)
        pid_file = os.path.join(PID_DIR, 'rqw_pid_%s.pid' % (queue_name))
        rqw = 'RqWorker Queue %s' % (queue_name)
        rqworker_start = (
            subprocess.Popen(
                [
                    RQWORKER, '-c', queue_settings
                ]
            )
        )
        rqworker_start.poll()
        rq_pid = str(rqworker_start.pid)
        os.chdir(PATH)
        if rq_pid:
            pid = open(pid_file, 'w')
            pid.write(rq_pid)
            pid.close()
            completed = True
            rql_msg = '%s started successfully\n' % (rqw)
            sys.stderr.write(rql_msg+'\n')
            logger.info(rql_msg)
        else:
            rql_msg = '%s stopped successfully\n' % (rqw)
            sys.stderr.write(rql_msg+'\n')
            logger.error(rql_msg)
            completed = False

    return(completed)

def rqworker_stop():
    completed = True

    for queue in RQ_WORKER_QUEUES:
        queue_name = re.sub(r'_settings', '', queue[1])
        pid_file = os.path.join(PID_DIR, 'rqw_pid_%s.pid' % (queue_name))
        rqw = 'RqWorker Queue %s' % (queue_name)
        if os.path.exists(pid_file):
            pid_exists = open(pid_file, 'r').read()
            if re.search(r'[0-9]+', pid_exists):
                try:
                    os.kill(int(pid_exists), signal.SIGTERM)
                    os.remove(pid_file)
                except Exception as e:
                    if e.errno == 3:
                        os.remove(pid_file)
                rql_msg = '%s stopped successfully\n' % (rqw)
                sys.stderr.write(rql_msg+'\n')
                logger.info(rql_msg)

            else:
                rql_msg = '%s couldnt be stopped\n' % (rqw)
                completed = False
                sys.stderr.write(rql_msg+'\n')
                logger.error(rql_msg)

        else:
            rql_msg = (
                '%s couldnt be stopped, pid file %s couldnt be found\n'
                % (rqw, pid_file)
            )
            completed = False
            sys.stderr.write(rql_msg+'\n')
            logger.error(rql_msg)

    return(completed, rql_msg)


def handler(signum, frame):
    print "returning back to terminal"

def start_service(pid_file, msg, service, service_options=list()):
    pid = run(PROGRAM, service, *service_options)
    pidfile = open(pid_file, 'w')
    pidfile.write(pid)
    pidfile.close()
    logger.info("{0} Service Started".format(msg))

def vfense_start():
    process_exists = 0
    for pidfile in PIDS:
        if os.path.exists(pidfile[0]):
            pid = open(pidfile[0], 'r').read()
            ps = subprocess.Popen(['ps', '-fe'], stdout=subprocess.PIPE)
            for i in ps.stdout.readlines():
                if re.search(r'[0-9]+', i.split()[1]):
                    if int(pid) == int(i.split()[1]):
                        process_exists = process_exists + 1
                        message = 'vFense service %s is already running.' \
                            % (pidfile[1])
                        sys.stderr.write(message+'\n')
                        logger.error(message)
                        sys.exit(1)
    if process_exists == 0:
        os.chdir(PATH)
        print 'vFense Server is starting. Please wait....'
        logger.info('vFense Server is starting. Please wait....')
        rqworker = rqworker_starter()
        if rqworker:
            listener_pids = (
                get_pids_for_service(
                    "vFense_listener.py", *get_port_settings("Listener")
                )
            )
            api_pids = (
                get_pids_for_service(
                    "vFense_web.py", *get_port_settings("Api")
                )
            )
            for service in listener_pids:
                start_service(
                    service["pid_file"], service["msg"], service["service"],
                    ['--ports={0}'.format(service["port"])]
                )
            for service in api_pids:
                start_service(
                    service["pid_file"], service["msg"], service["service"],
                    ['--ports={0}'.format(service["port"])]
                )
            for service in SERVICES:
                pid = run(PROGRAM, service[0])
                pidfile = open(service[1], 'w')
                pidfile.write(pid)
                pidfile.close()
                logger.info("%s Server Started" % (service[2]))
        sleep(1)
        signal.signal(signal.SIGINT, handler)
        print 'vFense Server has been started. Enjoy !!!'
        logger.info('vFense Server has been started. Enjoy !!!')


def vfense_stop():
    logger.info('vFense Services are going to shutdown now...')
    for service in ALLSERVICES:
        if os.path.exists(service[1]):
            pid = open(service[1], 'r').read()
            if re.search(r'[0-9]+', pid):
                try:
                    os.kill(int(pid), signal.SIGTERM)
                    os.remove(service[1])
                except Exception as e:
                    if e.errno == 3:
                        os.remove(service[1])
            sleep(2)
        else:
            msg = "vFense %s is not running. Stopping Failed..." \
                  % (service[2])
            sys.stderr.write(msg+'\n')
            logger.error(msg)

    rqworker_stop()

    print 'vFense Server has been stopped now !!!'
    logger.info('vFense Server has been stopped now !!!')


def vfense_restart():
    vfense_stop()
    print "\n"
    vfense_start()

def vfense_status():
    process_exists = 0
    for pidfile in PIDS:
        if os.path.exists(pidfile[0]):
            pid = open(pidfile[0], 'r').read()
            ps = subprocess.Popen(['ps', '-fe'], stdout=subprocess.PIPE)
            for i in ps.stdout.readlines():
                if re.search(r'[0-9]+', i.split()[1]):
                    if int(pid) == int(i.split()[1]):
                        process_exists = process_exists + 1
                        message = 'vFense service %s is running.' \
                            % (pidfile[1])
                        sys.stderr.write(message+'\n')
                        logger.info(message)
        else:
            message = 'vFense service %s is not running.' % (pidfile[1])
            sys.stderr.write(message+'\n')
            logger.error(message)
    sys.exit(0)

ACTIONS = sys.argv[1]

if __name__ == "__main__":
    if len(sys.argv) == 2:
        if ACTIONS == 'start':
            vfense_start()
        elif ACTIONS == 'stop':
            vfense_stop()
        elif ACTIONS == 'restart':
            vfense_restart()
            logger.info("vFense server restarting..")
        elif ACTIONS == 'status':
            vfense_status()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart|status" % sys.argv[0]
